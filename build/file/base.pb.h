// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_base_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_base_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_base_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_base_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_base_2eproto;
namespace XuChat {
class ChatSessionInfo;
struct ChatSessionInfoDefaultTypeInternal;
extern ChatSessionInfoDefaultTypeInternal _ChatSessionInfo_default_instance_;
class FileDownloadData;
struct FileDownloadDataDefaultTypeInternal;
extern FileDownloadDataDefaultTypeInternal _FileDownloadData_default_instance_;
class FileMessageInfo;
struct FileMessageInfoDefaultTypeInternal;
extern FileMessageInfoDefaultTypeInternal _FileMessageInfo_default_instance_;
class FileUploadData;
struct FileUploadDataDefaultTypeInternal;
extern FileUploadDataDefaultTypeInternal _FileUploadData_default_instance_;
class ImageMessageInfo;
struct ImageMessageInfoDefaultTypeInternal;
extern ImageMessageInfoDefaultTypeInternal _ImageMessageInfo_default_instance_;
class MessageContent;
struct MessageContentDefaultTypeInternal;
extern MessageContentDefaultTypeInternal _MessageContent_default_instance_;
class MessageInfo;
struct MessageInfoDefaultTypeInternal;
extern MessageInfoDefaultTypeInternal _MessageInfo_default_instance_;
class SpeechMessageInfo;
struct SpeechMessageInfoDefaultTypeInternal;
extern SpeechMessageInfoDefaultTypeInternal _SpeechMessageInfo_default_instance_;
class StringMessageInfo;
struct StringMessageInfoDefaultTypeInternal;
extern StringMessageInfoDefaultTypeInternal _StringMessageInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace XuChat
PROTOBUF_NAMESPACE_OPEN
template<> ::XuChat::ChatSessionInfo* Arena::CreateMaybeMessage<::XuChat::ChatSessionInfo>(Arena*);
template<> ::XuChat::FileDownloadData* Arena::CreateMaybeMessage<::XuChat::FileDownloadData>(Arena*);
template<> ::XuChat::FileMessageInfo* Arena::CreateMaybeMessage<::XuChat::FileMessageInfo>(Arena*);
template<> ::XuChat::FileUploadData* Arena::CreateMaybeMessage<::XuChat::FileUploadData>(Arena*);
template<> ::XuChat::ImageMessageInfo* Arena::CreateMaybeMessage<::XuChat::ImageMessageInfo>(Arena*);
template<> ::XuChat::MessageContent* Arena::CreateMaybeMessage<::XuChat::MessageContent>(Arena*);
template<> ::XuChat::MessageInfo* Arena::CreateMaybeMessage<::XuChat::MessageInfo>(Arena*);
template<> ::XuChat::SpeechMessageInfo* Arena::CreateMaybeMessage<::XuChat::SpeechMessageInfo>(Arena*);
template<> ::XuChat::StringMessageInfo* Arena::CreateMaybeMessage<::XuChat::StringMessageInfo>(Arena*);
template<> ::XuChat::UserInfo* Arena::CreateMaybeMessage<::XuChat::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XuChat {

enum MessageType : int {
  STRING = 0,
  IMAGE = 1,
  FILE = 2,
  SPEECH = 3,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = STRING;
constexpr MessageType MessageType_MAX = SPEECH;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kPhoneFieldNumber = 4,
    kAvatarFieldNumber = 5,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string phone = 4;
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // bytes avatar = 5;
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // @@protoc_insertion_point(class_scope:XuChat.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class ChatSessionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.ChatSessionInfo) */ {
 public:
  inline ChatSessionInfo() : ChatSessionInfo(nullptr) {}
  ~ChatSessionInfo() override;
  explicit PROTOBUF_CONSTEXPR ChatSessionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatSessionInfo(const ChatSessionInfo& from);
  ChatSessionInfo(ChatSessionInfo&& from) noexcept
    : ChatSessionInfo() {
    *this = ::std::move(from);
  }

  inline ChatSessionInfo& operator=(const ChatSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatSessionInfo& operator=(ChatSessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatSessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatSessionInfo* internal_default_instance() {
    return reinterpret_cast<const ChatSessionInfo*>(
               &_ChatSessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChatSessionInfo& a, ChatSessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatSessionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatSessionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatSessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatSessionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatSessionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChatSessionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatSessionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.ChatSessionInfo";
  }
  protected:
  explicit ChatSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleChatFriendIdFieldNumber = 1,
    kChatSessionIdFieldNumber = 2,
    kChatSessionNameFieldNumber = 3,
    kAvatarFieldNumber = 5,
    kPrevMessageFieldNumber = 4,
  };
  // optional string single_chat_friend_id = 1;
  bool has_single_chat_friend_id() const;
  private:
  bool _internal_has_single_chat_friend_id() const;
  public:
  void clear_single_chat_friend_id();
  const std::string& single_chat_friend_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_single_chat_friend_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_single_chat_friend_id();
  PROTOBUF_NODISCARD std::string* release_single_chat_friend_id();
  void set_allocated_single_chat_friend_id(std::string* single_chat_friend_id);
  private:
  const std::string& _internal_single_chat_friend_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_single_chat_friend_id(const std::string& value);
  std::string* _internal_mutable_single_chat_friend_id();
  public:

  // string chat_session_id = 2;
  void clear_chat_session_id();
  const std::string& chat_session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_session_id();
  PROTOBUF_NODISCARD std::string* release_chat_session_id();
  void set_allocated_chat_session_id(std::string* chat_session_id);
  private:
  const std::string& _internal_chat_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_session_id(const std::string& value);
  std::string* _internal_mutable_chat_session_id();
  public:

  // string chat_session_name = 3;
  void clear_chat_session_name();
  const std::string& chat_session_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_session_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_session_name();
  PROTOBUF_NODISCARD std::string* release_chat_session_name();
  void set_allocated_chat_session_name(std::string* chat_session_name);
  private:
  const std::string& _internal_chat_session_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_session_name(const std::string& value);
  std::string* _internal_mutable_chat_session_name();
  public:

  // optional bytes avatar = 5;
  bool has_avatar() const;
  private:
  bool _internal_has_avatar() const;
  public:
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // optional .XuChat.MessageInfo prev_message = 4;
  bool has_prev_message() const;
  private:
  bool _internal_has_prev_message() const;
  public:
  void clear_prev_message();
  const ::XuChat::MessageInfo& prev_message() const;
  PROTOBUF_NODISCARD ::XuChat::MessageInfo* release_prev_message();
  ::XuChat::MessageInfo* mutable_prev_message();
  void set_allocated_prev_message(::XuChat::MessageInfo* prev_message);
  private:
  const ::XuChat::MessageInfo& _internal_prev_message() const;
  ::XuChat::MessageInfo* _internal_mutable_prev_message();
  public:
  void unsafe_arena_set_allocated_prev_message(
      ::XuChat::MessageInfo* prev_message);
  ::XuChat::MessageInfo* unsafe_arena_release_prev_message();

  // @@protoc_insertion_point(class_scope:XuChat.ChatSessionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr single_chat_friend_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_session_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
  ::XuChat::MessageInfo* prev_message_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class StringMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.StringMessageInfo) */ {
 public:
  inline StringMessageInfo() : StringMessageInfo(nullptr) {}
  ~StringMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR StringMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringMessageInfo(const StringMessageInfo& from);
  StringMessageInfo(StringMessageInfo&& from) noexcept
    : StringMessageInfo() {
    *this = ::std::move(from);
  }

  inline StringMessageInfo& operator=(const StringMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMessageInfo& operator=(StringMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringMessageInfo* internal_default_instance() {
    return reinterpret_cast<const StringMessageInfo*>(
               &_StringMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StringMessageInfo& a, StringMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StringMessageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.StringMessageInfo";
  }
  protected:
  explicit StringMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:XuChat.StringMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class ImageMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.ImageMessageInfo) */ {
 public:
  inline ImageMessageInfo() : ImageMessageInfo(nullptr) {}
  ~ImageMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR ImageMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageMessageInfo(const ImageMessageInfo& from);
  ImageMessageInfo(ImageMessageInfo&& from) noexcept
    : ImageMessageInfo() {
    *this = ::std::move(from);
  }

  inline ImageMessageInfo& operator=(const ImageMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageMessageInfo& operator=(ImageMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ImageMessageInfo*>(
               &_ImageMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImageMessageInfo& a, ImageMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImageMessageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.ImageMessageInfo";
  }
  protected:
  explicit ImageMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kImageContentFieldNumber = 2,
  };
  // optional string file_id = 1;
  bool has_file_id() const;
  private:
  bool _internal_has_file_id() const;
  public:
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // optional bytes image_content = 2;
  bool has_image_content() const;
  private:
  bool _internal_has_image_content() const;
  public:
  void clear_image_content();
  const std::string& image_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_content();
  PROTOBUF_NODISCARD std::string* release_image_content();
  void set_allocated_image_content(std::string* image_content);
  private:
  const std::string& _internal_image_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_content(const std::string& value);
  std::string* _internal_mutable_image_content();
  public:

  // @@protoc_insertion_point(class_scope:XuChat.ImageMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_content_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class FileMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.FileMessageInfo) */ {
 public:
  inline FileMessageInfo() : FileMessageInfo(nullptr) {}
  ~FileMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR FileMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileMessageInfo(const FileMessageInfo& from);
  FileMessageInfo(FileMessageInfo&& from) noexcept
    : FileMessageInfo() {
    *this = ::std::move(from);
  }

  inline FileMessageInfo& operator=(const FileMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMessageInfo& operator=(FileMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMessageInfo* internal_default_instance() {
    return reinterpret_cast<const FileMessageInfo*>(
               &_FileMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileMessageInfo& a, FileMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileMessageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.FileMessageInfo";
  }
  protected:
  explicit FileMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileNameFieldNumber = 3,
    kFileContentsFieldNumber = 4,
    kFileSizeFieldNumber = 2,
  };
  // optional string file_id = 1;
  bool has_file_id() const;
  private:
  bool _internal_has_file_id() const;
  public:
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // optional string file_name = 3;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // optional bytes file_contents = 4;
  bool has_file_contents() const;
  private:
  bool _internal_has_file_contents() const;
  public:
  void clear_file_contents();
  const std::string& file_contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_contents();
  PROTOBUF_NODISCARD std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // optional int64 file_size = 2;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XuChat.FileMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
  int64_t file_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class SpeechMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.SpeechMessageInfo) */ {
 public:
  inline SpeechMessageInfo() : SpeechMessageInfo(nullptr) {}
  ~SpeechMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR SpeechMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeechMessageInfo(const SpeechMessageInfo& from);
  SpeechMessageInfo(SpeechMessageInfo&& from) noexcept
    : SpeechMessageInfo() {
    *this = ::std::move(from);
  }

  inline SpeechMessageInfo& operator=(const SpeechMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechMessageInfo& operator=(SpeechMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeechMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeechMessageInfo* internal_default_instance() {
    return reinterpret_cast<const SpeechMessageInfo*>(
               &_SpeechMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SpeechMessageInfo& a, SpeechMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeechMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeechMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeechMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpeechMessageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.SpeechMessageInfo";
  }
  protected:
  explicit SpeechMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileContentsFieldNumber = 2,
  };
  // optional string file_id = 1;
  bool has_file_id() const;
  private:
  bool _internal_has_file_id() const;
  public:
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // optional bytes file_contents = 2;
  bool has_file_contents() const;
  private:
  bool _internal_has_file_contents() const;
  public:
  void clear_file_contents();
  const std::string& file_contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_contents();
  PROTOBUF_NODISCARD std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // @@protoc_insertion_point(class_scope:XuChat.SpeechMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class MessageContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.MessageContent) */ {
 public:
  inline MessageContent() : MessageContent(nullptr) {}
  ~MessageContent() override;
  explicit PROTOBUF_CONSTEXPR MessageContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageContent(const MessageContent& from);
  MessageContent(MessageContent&& from) noexcept
    : MessageContent() {
    *this = ::std::move(from);
  }

  inline MessageContent& operator=(const MessageContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageContent& operator=(MessageContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageContent& default_instance() {
    return *internal_default_instance();
  }
  enum MsgContentCase {
    kStringMessage = 2,
    kFileMessage = 3,
    kSpeechMessage = 4,
    kImageMessage = 5,
    MSG_CONTENT_NOT_SET = 0,
  };

  static inline const MessageContent* internal_default_instance() {
    return reinterpret_cast<const MessageContent*>(
               &_MessageContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageContent& a, MessageContent& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageContent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.MessageContent";
  }
  protected:
  explicit MessageContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kStringMessageFieldNumber = 2,
    kFileMessageFieldNumber = 3,
    kSpeechMessageFieldNumber = 4,
    kImageMessageFieldNumber = 5,
  };
  // .XuChat.MessageType message_type = 1;
  void clear_message_type();
  ::XuChat::MessageType message_type() const;
  void set_message_type(::XuChat::MessageType value);
  private:
  ::XuChat::MessageType _internal_message_type() const;
  void _internal_set_message_type(::XuChat::MessageType value);
  public:

  // .XuChat.StringMessageInfo string_message = 2;
  bool has_string_message() const;
  private:
  bool _internal_has_string_message() const;
  public:
  void clear_string_message();
  const ::XuChat::StringMessageInfo& string_message() const;
  PROTOBUF_NODISCARD ::XuChat::StringMessageInfo* release_string_message();
  ::XuChat::StringMessageInfo* mutable_string_message();
  void set_allocated_string_message(::XuChat::StringMessageInfo* string_message);
  private:
  const ::XuChat::StringMessageInfo& _internal_string_message() const;
  ::XuChat::StringMessageInfo* _internal_mutable_string_message();
  public:
  void unsafe_arena_set_allocated_string_message(
      ::XuChat::StringMessageInfo* string_message);
  ::XuChat::StringMessageInfo* unsafe_arena_release_string_message();

  // .XuChat.FileMessageInfo file_message = 3;
  bool has_file_message() const;
  private:
  bool _internal_has_file_message() const;
  public:
  void clear_file_message();
  const ::XuChat::FileMessageInfo& file_message() const;
  PROTOBUF_NODISCARD ::XuChat::FileMessageInfo* release_file_message();
  ::XuChat::FileMessageInfo* mutable_file_message();
  void set_allocated_file_message(::XuChat::FileMessageInfo* file_message);
  private:
  const ::XuChat::FileMessageInfo& _internal_file_message() const;
  ::XuChat::FileMessageInfo* _internal_mutable_file_message();
  public:
  void unsafe_arena_set_allocated_file_message(
      ::XuChat::FileMessageInfo* file_message);
  ::XuChat::FileMessageInfo* unsafe_arena_release_file_message();

  // .XuChat.SpeechMessageInfo speech_message = 4;
  bool has_speech_message() const;
  private:
  bool _internal_has_speech_message() const;
  public:
  void clear_speech_message();
  const ::XuChat::SpeechMessageInfo& speech_message() const;
  PROTOBUF_NODISCARD ::XuChat::SpeechMessageInfo* release_speech_message();
  ::XuChat::SpeechMessageInfo* mutable_speech_message();
  void set_allocated_speech_message(::XuChat::SpeechMessageInfo* speech_message);
  private:
  const ::XuChat::SpeechMessageInfo& _internal_speech_message() const;
  ::XuChat::SpeechMessageInfo* _internal_mutable_speech_message();
  public:
  void unsafe_arena_set_allocated_speech_message(
      ::XuChat::SpeechMessageInfo* speech_message);
  ::XuChat::SpeechMessageInfo* unsafe_arena_release_speech_message();

  // .XuChat.ImageMessageInfo image_message = 5;
  bool has_image_message() const;
  private:
  bool _internal_has_image_message() const;
  public:
  void clear_image_message();
  const ::XuChat::ImageMessageInfo& image_message() const;
  PROTOBUF_NODISCARD ::XuChat::ImageMessageInfo* release_image_message();
  ::XuChat::ImageMessageInfo* mutable_image_message();
  void set_allocated_image_message(::XuChat::ImageMessageInfo* image_message);
  private:
  const ::XuChat::ImageMessageInfo& _internal_image_message() const;
  ::XuChat::ImageMessageInfo* _internal_mutable_image_message();
  public:
  void unsafe_arena_set_allocated_image_message(
      ::XuChat::ImageMessageInfo* image_message);
  ::XuChat::ImageMessageInfo* unsafe_arena_release_image_message();

  void clear_msg_content();
  MsgContentCase msg_content_case() const;
  // @@protoc_insertion_point(class_scope:XuChat.MessageContent)
 private:
  class _Internal;
  void set_has_string_message();
  void set_has_file_message();
  void set_has_speech_message();
  void set_has_image_message();

  inline bool has_msg_content() const;
  inline void clear_has_msg_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int message_type_;
  union MsgContentUnion {
    constexpr MsgContentUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::XuChat::StringMessageInfo* string_message_;
    ::XuChat::FileMessageInfo* file_message_;
    ::XuChat::SpeechMessageInfo* speech_message_;
    ::XuChat::ImageMessageInfo* image_message_;
  } msg_content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class MessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.MessageInfo) */ {
 public:
  inline MessageInfo() : MessageInfo(nullptr) {}
  ~MessageInfo() override;
  explicit PROTOBUF_CONSTEXPR MessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageInfo(const MessageInfo& from);
  MessageInfo(MessageInfo&& from) noexcept
    : MessageInfo() {
    *this = ::std::move(from);
  }

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageInfo& operator=(MessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageInfo* internal_default_instance() {
    return reinterpret_cast<const MessageInfo*>(
               &_MessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MessageInfo& a, MessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.MessageInfo";
  }
  protected:
  explicit MessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kChatSessionIdFieldNumber = 2,
    kSenderFieldNumber = 4,
    kMessageFieldNumber = 5,
    kTimestampFieldNumber = 3,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string chat_session_id = 2;
  void clear_chat_session_id();
  const std::string& chat_session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_session_id();
  PROTOBUF_NODISCARD std::string* release_chat_session_id();
  void set_allocated_chat_session_id(std::string* chat_session_id);
  private:
  const std::string& _internal_chat_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_session_id(const std::string& value);
  std::string* _internal_mutable_chat_session_id();
  public:

  // .XuChat.UserInfo sender = 4;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::XuChat::UserInfo& sender() const;
  PROTOBUF_NODISCARD ::XuChat::UserInfo* release_sender();
  ::XuChat::UserInfo* mutable_sender();
  void set_allocated_sender(::XuChat::UserInfo* sender);
  private:
  const ::XuChat::UserInfo& _internal_sender() const;
  ::XuChat::UserInfo* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::XuChat::UserInfo* sender);
  ::XuChat::UserInfo* unsafe_arena_release_sender();

  // .XuChat.MessageContent message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::XuChat::MessageContent& message() const;
  PROTOBUF_NODISCARD ::XuChat::MessageContent* release_message();
  ::XuChat::MessageContent* mutable_message();
  void set_allocated_message(::XuChat::MessageContent* message);
  private:
  const ::XuChat::MessageContent& _internal_message() const;
  ::XuChat::MessageContent* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::XuChat::MessageContent* message);
  ::XuChat::MessageContent* unsafe_arena_release_message();

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XuChat.MessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_session_id_;
  ::XuChat::UserInfo* sender_;
  ::XuChat::MessageContent* message_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class FileDownloadData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.FileDownloadData) */ {
 public:
  inline FileDownloadData() : FileDownloadData(nullptr) {}
  ~FileDownloadData() override;
  explicit PROTOBUF_CONSTEXPR FileDownloadData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileDownloadData(const FileDownloadData& from);
  FileDownloadData(FileDownloadData&& from) noexcept
    : FileDownloadData() {
    *this = ::std::move(from);
  }

  inline FileDownloadData& operator=(const FileDownloadData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileDownloadData& operator=(FileDownloadData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileDownloadData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileDownloadData* internal_default_instance() {
    return reinterpret_cast<const FileDownloadData*>(
               &_FileDownloadData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FileDownloadData& a, FileDownloadData& b) {
    a.Swap(&b);
  }
  inline void Swap(FileDownloadData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileDownloadData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileDownloadData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileDownloadData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileDownloadData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileDownloadData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileDownloadData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.FileDownloadData";
  }
  protected:
  explicit FileDownloadData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileContentFieldNumber = 2,
  };
  // string file_id = 1;
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // bytes file_content = 2;
  void clear_file_content();
  const std::string& file_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_content();
  PROTOBUF_NODISCARD std::string* release_file_content();
  void set_allocated_file_content(std::string* file_content);
  private:
  const std::string& _internal_file_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_content(const std::string& value);
  std::string* _internal_mutable_file_content();
  public:

  // @@protoc_insertion_point(class_scope:XuChat.FileDownloadData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class FileUploadData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XuChat.FileUploadData) */ {
 public:
  inline FileUploadData() : FileUploadData(nullptr) {}
  ~FileUploadData() override;
  explicit PROTOBUF_CONSTEXPR FileUploadData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileUploadData(const FileUploadData& from);
  FileUploadData(FileUploadData&& from) noexcept
    : FileUploadData() {
    *this = ::std::move(from);
  }

  inline FileUploadData& operator=(const FileUploadData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileUploadData& operator=(FileUploadData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileUploadData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileUploadData* internal_default_instance() {
    return reinterpret_cast<const FileUploadData*>(
               &_FileUploadData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FileUploadData& a, FileUploadData& b) {
    a.Swap(&b);
  }
  inline void Swap(FileUploadData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileUploadData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileUploadData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileUploadData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileUploadData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileUploadData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileUploadData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XuChat.FileUploadData";
  }
  protected:
  explicit FileUploadData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kFileContentFieldNumber = 3,
    kFileSizeFieldNumber = 2,
  };
  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // bytes file_content = 3;
  void clear_file_content();
  const std::string& file_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_content();
  PROTOBUF_NODISCARD std::string* release_file_content();
  void set_allocated_file_content(std::string* file_content);
  private:
  const std::string& _internal_file_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_content(const std::string& value);
  std::string* _internal_mutable_file_content();
  public:

  // int64 file_size = 2;
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XuChat.FileUploadData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_content_;
  int64_t file_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserInfo

// string user_id = 1;
inline void UserInfo::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:XuChat.UserInfo.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.UserInfo.user_id)
}
inline std::string* UserInfo::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:XuChat.UserInfo.user_id)
  return _s;
}
inline const std::string& UserInfo::_internal_user_id() const {
  return user_id_.Get();
}
inline void UserInfo::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:XuChat.UserInfo.user_id)
  return user_id_.Release();
}
inline void UserInfo::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.UserInfo.user_id)
}

// string nickname = 2;
inline void UserInfo::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& UserInfo::nickname() const {
  // @@protoc_insertion_point(field_get:XuChat.UserInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.UserInfo.nickname)
}
inline std::string* UserInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:XuChat.UserInfo.nickname)
  return _s;
}
inline const std::string& UserInfo::_internal_nickname() const {
  return nickname_.Get();
}
inline void UserInfo::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_nickname() {
  
  return nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:XuChat.UserInfo.nickname)
  return nickname_.Release();
}
inline void UserInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault()) {
    nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.UserInfo.nickname)
}

// string description = 3;
inline void UserInfo::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& UserInfo::description() const {
  // @@protoc_insertion_point(field_get:XuChat.UserInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.UserInfo.description)
}
inline std::string* UserInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:XuChat.UserInfo.description)
  return _s;
}
inline const std::string& UserInfo::_internal_description() const {
  return description_.Get();
}
inline void UserInfo::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_description() {
  // @@protoc_insertion_point(field_release:XuChat.UserInfo.description)
  return description_.Release();
}
inline void UserInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.UserInfo.description)
}

// string phone = 4;
inline void UserInfo::clear_phone() {
  phone_.ClearToEmpty();
}
inline const std::string& UserInfo::phone() const {
  // @@protoc_insertion_point(field_get:XuChat.UserInfo.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_phone(ArgT0&& arg0, ArgT... args) {
 
 phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.UserInfo.phone)
}
inline std::string* UserInfo::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:XuChat.UserInfo.phone)
  return _s;
}
inline const std::string& UserInfo::_internal_phone() const {
  return phone_.Get();
}
inline void UserInfo::_internal_set_phone(const std::string& value) {
  
  phone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_phone() {
  
  return phone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_phone() {
  // @@protoc_insertion_point(field_release:XuChat.UserInfo.phone)
  return phone_.Release();
}
inline void UserInfo::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (phone_.IsDefault()) {
    phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.UserInfo.phone)
}

// bytes avatar = 5;
inline void UserInfo::clear_avatar() {
  avatar_.ClearToEmpty();
}
inline const std::string& UserInfo::avatar() const {
  // @@protoc_insertion_point(field_get:XuChat.UserInfo.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_avatar(ArgT0&& arg0, ArgT... args) {
 
 avatar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.UserInfo.avatar)
}
inline std::string* UserInfo::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:XuChat.UserInfo.avatar)
  return _s;
}
inline const std::string& UserInfo::_internal_avatar() const {
  return avatar_.Get();
}
inline void UserInfo::_internal_set_avatar(const std::string& value) {
  
  avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_avatar() {
  
  return avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:XuChat.UserInfo.avatar)
  return avatar_.Release();
}
inline void UserInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_.IsDefault()) {
    avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.UserInfo.avatar)
}

// -------------------------------------------------------------------

// ChatSessionInfo

// optional string single_chat_friend_id = 1;
inline bool ChatSessionInfo::_internal_has_single_chat_friend_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatSessionInfo::has_single_chat_friend_id() const {
  return _internal_has_single_chat_friend_id();
}
inline void ChatSessionInfo::clear_single_chat_friend_id() {
  single_chat_friend_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatSessionInfo::single_chat_friend_id() const {
  // @@protoc_insertion_point(field_get:XuChat.ChatSessionInfo.single_chat_friend_id)
  return _internal_single_chat_friend_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatSessionInfo::set_single_chat_friend_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 single_chat_friend_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.ChatSessionInfo.single_chat_friend_id)
}
inline std::string* ChatSessionInfo::mutable_single_chat_friend_id() {
  std::string* _s = _internal_mutable_single_chat_friend_id();
  // @@protoc_insertion_point(field_mutable:XuChat.ChatSessionInfo.single_chat_friend_id)
  return _s;
}
inline const std::string& ChatSessionInfo::_internal_single_chat_friend_id() const {
  return single_chat_friend_id_.Get();
}
inline void ChatSessionInfo::_internal_set_single_chat_friend_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  single_chat_friend_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::_internal_mutable_single_chat_friend_id() {
  _has_bits_[0] |= 0x00000001u;
  return single_chat_friend_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::release_single_chat_friend_id() {
  // @@protoc_insertion_point(field_release:XuChat.ChatSessionInfo.single_chat_friend_id)
  if (!_internal_has_single_chat_friend_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = single_chat_friend_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (single_chat_friend_id_.IsDefault()) {
    single_chat_friend_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatSessionInfo::set_allocated_single_chat_friend_id(std::string* single_chat_friend_id) {
  if (single_chat_friend_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  single_chat_friend_id_.SetAllocated(single_chat_friend_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (single_chat_friend_id_.IsDefault()) {
    single_chat_friend_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.ChatSessionInfo.single_chat_friend_id)
}

// string chat_session_id = 2;
inline void ChatSessionInfo::clear_chat_session_id() {
  chat_session_id_.ClearToEmpty();
}
inline const std::string& ChatSessionInfo::chat_session_id() const {
  // @@protoc_insertion_point(field_get:XuChat.ChatSessionInfo.chat_session_id)
  return _internal_chat_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatSessionInfo::set_chat_session_id(ArgT0&& arg0, ArgT... args) {
 
 chat_session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.ChatSessionInfo.chat_session_id)
}
inline std::string* ChatSessionInfo::mutable_chat_session_id() {
  std::string* _s = _internal_mutable_chat_session_id();
  // @@protoc_insertion_point(field_mutable:XuChat.ChatSessionInfo.chat_session_id)
  return _s;
}
inline const std::string& ChatSessionInfo::_internal_chat_session_id() const {
  return chat_session_id_.Get();
}
inline void ChatSessionInfo::_internal_set_chat_session_id(const std::string& value) {
  
  chat_session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::_internal_mutable_chat_session_id() {
  
  return chat_session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::release_chat_session_id() {
  // @@protoc_insertion_point(field_release:XuChat.ChatSessionInfo.chat_session_id)
  return chat_session_id_.Release();
}
inline void ChatSessionInfo::set_allocated_chat_session_id(std::string* chat_session_id) {
  if (chat_session_id != nullptr) {
    
  } else {
    
  }
  chat_session_id_.SetAllocated(chat_session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_session_id_.IsDefault()) {
    chat_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.ChatSessionInfo.chat_session_id)
}

// string chat_session_name = 3;
inline void ChatSessionInfo::clear_chat_session_name() {
  chat_session_name_.ClearToEmpty();
}
inline const std::string& ChatSessionInfo::chat_session_name() const {
  // @@protoc_insertion_point(field_get:XuChat.ChatSessionInfo.chat_session_name)
  return _internal_chat_session_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatSessionInfo::set_chat_session_name(ArgT0&& arg0, ArgT... args) {
 
 chat_session_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.ChatSessionInfo.chat_session_name)
}
inline std::string* ChatSessionInfo::mutable_chat_session_name() {
  std::string* _s = _internal_mutable_chat_session_name();
  // @@protoc_insertion_point(field_mutable:XuChat.ChatSessionInfo.chat_session_name)
  return _s;
}
inline const std::string& ChatSessionInfo::_internal_chat_session_name() const {
  return chat_session_name_.Get();
}
inline void ChatSessionInfo::_internal_set_chat_session_name(const std::string& value) {
  
  chat_session_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::_internal_mutable_chat_session_name() {
  
  return chat_session_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::release_chat_session_name() {
  // @@protoc_insertion_point(field_release:XuChat.ChatSessionInfo.chat_session_name)
  return chat_session_name_.Release();
}
inline void ChatSessionInfo::set_allocated_chat_session_name(std::string* chat_session_name) {
  if (chat_session_name != nullptr) {
    
  } else {
    
  }
  chat_session_name_.SetAllocated(chat_session_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_session_name_.IsDefault()) {
    chat_session_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.ChatSessionInfo.chat_session_name)
}

// optional .XuChat.MessageInfo prev_message = 4;
inline bool ChatSessionInfo::_internal_has_prev_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || prev_message_ != nullptr);
  return value;
}
inline bool ChatSessionInfo::has_prev_message() const {
  return _internal_has_prev_message();
}
inline void ChatSessionInfo::clear_prev_message() {
  if (prev_message_ != nullptr) prev_message_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::XuChat::MessageInfo& ChatSessionInfo::_internal_prev_message() const {
  const ::XuChat::MessageInfo* p = prev_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::XuChat::MessageInfo&>(
      ::XuChat::_MessageInfo_default_instance_);
}
inline const ::XuChat::MessageInfo& ChatSessionInfo::prev_message() const {
  // @@protoc_insertion_point(field_get:XuChat.ChatSessionInfo.prev_message)
  return _internal_prev_message();
}
inline void ChatSessionInfo::unsafe_arena_set_allocated_prev_message(
    ::XuChat::MessageInfo* prev_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_message_);
  }
  prev_message_ = prev_message;
  if (prev_message) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.ChatSessionInfo.prev_message)
}
inline ::XuChat::MessageInfo* ChatSessionInfo::release_prev_message() {
  _has_bits_[0] &= ~0x00000004u;
  ::XuChat::MessageInfo* temp = prev_message_;
  prev_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XuChat::MessageInfo* ChatSessionInfo::unsafe_arena_release_prev_message() {
  // @@protoc_insertion_point(field_release:XuChat.ChatSessionInfo.prev_message)
  _has_bits_[0] &= ~0x00000004u;
  ::XuChat::MessageInfo* temp = prev_message_;
  prev_message_ = nullptr;
  return temp;
}
inline ::XuChat::MessageInfo* ChatSessionInfo::_internal_mutable_prev_message() {
  _has_bits_[0] |= 0x00000004u;
  if (prev_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::XuChat::MessageInfo>(GetArenaForAllocation());
    prev_message_ = p;
  }
  return prev_message_;
}
inline ::XuChat::MessageInfo* ChatSessionInfo::mutable_prev_message() {
  ::XuChat::MessageInfo* _msg = _internal_mutable_prev_message();
  // @@protoc_insertion_point(field_mutable:XuChat.ChatSessionInfo.prev_message)
  return _msg;
}
inline void ChatSessionInfo::set_allocated_prev_message(::XuChat::MessageInfo* prev_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete prev_message_;
  }
  if (prev_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prev_message);
    if (message_arena != submessage_arena) {
      prev_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  prev_message_ = prev_message;
  // @@protoc_insertion_point(field_set_allocated:XuChat.ChatSessionInfo.prev_message)
}

// optional bytes avatar = 5;
inline bool ChatSessionInfo::_internal_has_avatar() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatSessionInfo::has_avatar() const {
  return _internal_has_avatar();
}
inline void ChatSessionInfo::clear_avatar() {
  avatar_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChatSessionInfo::avatar() const {
  // @@protoc_insertion_point(field_get:XuChat.ChatSessionInfo.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatSessionInfo::set_avatar(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 avatar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.ChatSessionInfo.avatar)
}
inline std::string* ChatSessionInfo::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:XuChat.ChatSessionInfo.avatar)
  return _s;
}
inline const std::string& ChatSessionInfo::_internal_avatar() const {
  return avatar_.Get();
}
inline void ChatSessionInfo::_internal_set_avatar(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::_internal_mutable_avatar() {
  _has_bits_[0] |= 0x00000002u;
  return avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatSessionInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:XuChat.ChatSessionInfo.avatar)
  if (!_internal_has_avatar()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = avatar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_.IsDefault()) {
    avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatSessionInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_.IsDefault()) {
    avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.ChatSessionInfo.avatar)
}

// -------------------------------------------------------------------

// StringMessageInfo

// string content = 1;
inline void StringMessageInfo::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& StringMessageInfo::content() const {
  // @@protoc_insertion_point(field_get:XuChat.StringMessageInfo.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringMessageInfo::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.StringMessageInfo.content)
}
inline std::string* StringMessageInfo::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:XuChat.StringMessageInfo.content)
  return _s;
}
inline const std::string& StringMessageInfo::_internal_content() const {
  return content_.Get();
}
inline void StringMessageInfo::_internal_set_content(const std::string& value) {
  
  content_.Set(value, GetArenaForAllocation());
}
inline std::string* StringMessageInfo::_internal_mutable_content() {
  
  return content_.Mutable(GetArenaForAllocation());
}
inline std::string* StringMessageInfo::release_content() {
  // @@protoc_insertion_point(field_release:XuChat.StringMessageInfo.content)
  return content_.Release();
}
inline void StringMessageInfo::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault()) {
    content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.StringMessageInfo.content)
}

// -------------------------------------------------------------------

// ImageMessageInfo

// optional string file_id = 1;
inline bool ImageMessageInfo::_internal_has_file_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageMessageInfo::has_file_id() const {
  return _internal_has_file_id();
}
inline void ImageMessageInfo::clear_file_id() {
  file_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageMessageInfo::file_id() const {
  // @@protoc_insertion_point(field_get:XuChat.ImageMessageInfo.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessageInfo::set_file_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.ImageMessageInfo.file_id)
}
inline std::string* ImageMessageInfo::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:XuChat.ImageMessageInfo.file_id)
  return _s;
}
inline const std::string& ImageMessageInfo::_internal_file_id() const {
  return file_id_.Get();
}
inline void ImageMessageInfo::_internal_set_file_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessageInfo::_internal_mutable_file_id() {
  _has_bits_[0] |= 0x00000001u;
  return file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessageInfo::release_file_id() {
  // @@protoc_insertion_point(field_release:XuChat.ImageMessageInfo.file_id)
  if (!_internal_has_file_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = file_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessageInfo::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.ImageMessageInfo.file_id)
}

// optional bytes image_content = 2;
inline bool ImageMessageInfo::_internal_has_image_content() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageMessageInfo::has_image_content() const {
  return _internal_has_image_content();
}
inline void ImageMessageInfo::clear_image_content() {
  image_content_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ImageMessageInfo::image_content() const {
  // @@protoc_insertion_point(field_get:XuChat.ImageMessageInfo.image_content)
  return _internal_image_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessageInfo::set_image_content(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 image_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.ImageMessageInfo.image_content)
}
inline std::string* ImageMessageInfo::mutable_image_content() {
  std::string* _s = _internal_mutable_image_content();
  // @@protoc_insertion_point(field_mutable:XuChat.ImageMessageInfo.image_content)
  return _s;
}
inline const std::string& ImageMessageInfo::_internal_image_content() const {
  return image_content_.Get();
}
inline void ImageMessageInfo::_internal_set_image_content(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  image_content_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessageInfo::_internal_mutable_image_content() {
  _has_bits_[0] |= 0x00000002u;
  return image_content_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessageInfo::release_image_content() {
  // @@protoc_insertion_point(field_release:XuChat.ImageMessageInfo.image_content)
  if (!_internal_has_image_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = image_content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_content_.IsDefault()) {
    image_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessageInfo::set_allocated_image_content(std::string* image_content) {
  if (image_content != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_content_.SetAllocated(image_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_content_.IsDefault()) {
    image_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.ImageMessageInfo.image_content)
}

// -------------------------------------------------------------------

// FileMessageInfo

// optional string file_id = 1;
inline bool FileMessageInfo::_internal_has_file_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_id() const {
  return _internal_has_file_id();
}
inline void FileMessageInfo::clear_file_id() {
  file_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileMessageInfo::file_id() const {
  // @@protoc_insertion_point(field_get:XuChat.FileMessageInfo.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileMessageInfo::set_file_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileMessageInfo.file_id)
}
inline std::string* FileMessageInfo::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:XuChat.FileMessageInfo.file_id)
  return _s;
}
inline const std::string& FileMessageInfo::_internal_file_id() const {
  return file_id_.Get();
}
inline void FileMessageInfo::_internal_set_file_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMessageInfo::_internal_mutable_file_id() {
  _has_bits_[0] |= 0x00000001u;
  return file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FileMessageInfo::release_file_id() {
  // @@protoc_insertion_point(field_release:XuChat.FileMessageInfo.file_id)
  if (!_internal_has_file_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = file_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileMessageInfo::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileMessageInfo.file_id)
}

// optional int64 file_size = 2;
inline bool FileMessageInfo::_internal_has_file_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_size() const {
  return _internal_has_file_size();
}
inline void FileMessageInfo::clear_file_size() {
  file_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t FileMessageInfo::_internal_file_size() const {
  return file_size_;
}
inline int64_t FileMessageInfo::file_size() const {
  // @@protoc_insertion_point(field_get:XuChat.FileMessageInfo.file_size)
  return _internal_file_size();
}
inline void FileMessageInfo::_internal_set_file_size(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  file_size_ = value;
}
inline void FileMessageInfo::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:XuChat.FileMessageInfo.file_size)
}

// optional string file_name = 3;
inline bool FileMessageInfo::_internal_has_file_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_name() const {
  return _internal_has_file_name();
}
inline void FileMessageInfo::clear_file_name() {
  file_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileMessageInfo::file_name() const {
  // @@protoc_insertion_point(field_get:XuChat.FileMessageInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileMessageInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileMessageInfo.file_name)
}
inline std::string* FileMessageInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:XuChat.FileMessageInfo.file_name)
  return _s;
}
inline const std::string& FileMessageInfo::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileMessageInfo::_internal_set_file_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMessageInfo::_internal_mutable_file_name() {
  _has_bits_[0] |= 0x00000002u;
  return file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileMessageInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:XuChat.FileMessageInfo.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault()) {
    file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileMessageInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault()) {
    file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileMessageInfo.file_name)
}

// optional bytes file_contents = 4;
inline bool FileMessageInfo::_internal_has_file_contents() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_contents() const {
  return _internal_has_file_contents();
}
inline void FileMessageInfo::clear_file_contents() {
  file_contents_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FileMessageInfo::file_contents() const {
  // @@protoc_insertion_point(field_get:XuChat.FileMessageInfo.file_contents)
  return _internal_file_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileMessageInfo::set_file_contents(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 file_contents_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileMessageInfo.file_contents)
}
inline std::string* FileMessageInfo::mutable_file_contents() {
  std::string* _s = _internal_mutable_file_contents();
  // @@protoc_insertion_point(field_mutable:XuChat.FileMessageInfo.file_contents)
  return _s;
}
inline const std::string& FileMessageInfo::_internal_file_contents() const {
  return file_contents_.Get();
}
inline void FileMessageInfo::_internal_set_file_contents(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  file_contents_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMessageInfo::_internal_mutable_file_contents() {
  _has_bits_[0] |= 0x00000004u;
  return file_contents_.Mutable(GetArenaForAllocation());
}
inline std::string* FileMessageInfo::release_file_contents() {
  // @@protoc_insertion_point(field_release:XuChat.FileMessageInfo.file_contents)
  if (!_internal_has_file_contents()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = file_contents_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_contents_.IsDefault()) {
    file_contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileMessageInfo::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  file_contents_.SetAllocated(file_contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_contents_.IsDefault()) {
    file_contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileMessageInfo.file_contents)
}

// -------------------------------------------------------------------

// SpeechMessageInfo

// optional string file_id = 1;
inline bool SpeechMessageInfo::_internal_has_file_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeechMessageInfo::has_file_id() const {
  return _internal_has_file_id();
}
inline void SpeechMessageInfo::clear_file_id() {
  file_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SpeechMessageInfo::file_id() const {
  // @@protoc_insertion_point(field_get:XuChat.SpeechMessageInfo.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpeechMessageInfo::set_file_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.SpeechMessageInfo.file_id)
}
inline std::string* SpeechMessageInfo::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:XuChat.SpeechMessageInfo.file_id)
  return _s;
}
inline const std::string& SpeechMessageInfo::_internal_file_id() const {
  return file_id_.Get();
}
inline void SpeechMessageInfo::_internal_set_file_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpeechMessageInfo::_internal_mutable_file_id() {
  _has_bits_[0] |= 0x00000001u;
  return file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SpeechMessageInfo::release_file_id() {
  // @@protoc_insertion_point(field_release:XuChat.SpeechMessageInfo.file_id)
  if (!_internal_has_file_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = file_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SpeechMessageInfo::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.SpeechMessageInfo.file_id)
}

// optional bytes file_contents = 2;
inline bool SpeechMessageInfo::_internal_has_file_contents() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeechMessageInfo::has_file_contents() const {
  return _internal_has_file_contents();
}
inline void SpeechMessageInfo::clear_file_contents() {
  file_contents_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SpeechMessageInfo::file_contents() const {
  // @@protoc_insertion_point(field_get:XuChat.SpeechMessageInfo.file_contents)
  return _internal_file_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpeechMessageInfo::set_file_contents(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 file_contents_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.SpeechMessageInfo.file_contents)
}
inline std::string* SpeechMessageInfo::mutable_file_contents() {
  std::string* _s = _internal_mutable_file_contents();
  // @@protoc_insertion_point(field_mutable:XuChat.SpeechMessageInfo.file_contents)
  return _s;
}
inline const std::string& SpeechMessageInfo::_internal_file_contents() const {
  return file_contents_.Get();
}
inline void SpeechMessageInfo::_internal_set_file_contents(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_contents_.Set(value, GetArenaForAllocation());
}
inline std::string* SpeechMessageInfo::_internal_mutable_file_contents() {
  _has_bits_[0] |= 0x00000002u;
  return file_contents_.Mutable(GetArenaForAllocation());
}
inline std::string* SpeechMessageInfo::release_file_contents() {
  // @@protoc_insertion_point(field_release:XuChat.SpeechMessageInfo.file_contents)
  if (!_internal_has_file_contents()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = file_contents_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_contents_.IsDefault()) {
    file_contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SpeechMessageInfo::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_contents_.SetAllocated(file_contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_contents_.IsDefault()) {
    file_contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.SpeechMessageInfo.file_contents)
}

// -------------------------------------------------------------------

// MessageContent

// .XuChat.MessageType message_type = 1;
inline void MessageContent::clear_message_type() {
  message_type_ = 0;
}
inline ::XuChat::MessageType MessageContent::_internal_message_type() const {
  return static_cast< ::XuChat::MessageType >(message_type_);
}
inline ::XuChat::MessageType MessageContent::message_type() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageContent.message_type)
  return _internal_message_type();
}
inline void MessageContent::_internal_set_message_type(::XuChat::MessageType value) {
  
  message_type_ = value;
}
inline void MessageContent::set_message_type(::XuChat::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:XuChat.MessageContent.message_type)
}

// .XuChat.StringMessageInfo string_message = 2;
inline bool MessageContent::_internal_has_string_message() const {
  return msg_content_case() == kStringMessage;
}
inline bool MessageContent::has_string_message() const {
  return _internal_has_string_message();
}
inline void MessageContent::set_has_string_message() {
  _oneof_case_[0] = kStringMessage;
}
inline void MessageContent::clear_string_message() {
  if (_internal_has_string_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_content_.string_message_;
    }
    clear_has_msg_content();
  }
}
inline ::XuChat::StringMessageInfo* MessageContent::release_string_message() {
  // @@protoc_insertion_point(field_release:XuChat.MessageContent.string_message)
  if (_internal_has_string_message()) {
    clear_has_msg_content();
    ::XuChat::StringMessageInfo* temp = msg_content_.string_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::XuChat::StringMessageInfo& MessageContent::_internal_string_message() const {
  return _internal_has_string_message()
      ? *msg_content_.string_message_
      : reinterpret_cast< ::XuChat::StringMessageInfo&>(::XuChat::_StringMessageInfo_default_instance_);
}
inline const ::XuChat::StringMessageInfo& MessageContent::string_message() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageContent.string_message)
  return _internal_string_message();
}
inline ::XuChat::StringMessageInfo* MessageContent::unsafe_arena_release_string_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:XuChat.MessageContent.string_message)
  if (_internal_has_string_message()) {
    clear_has_msg_content();
    ::XuChat::StringMessageInfo* temp = msg_content_.string_message_;
    msg_content_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_string_message(::XuChat::StringMessageInfo* string_message) {
  clear_msg_content();
  if (string_message) {
    set_has_string_message();
    msg_content_.string_message_ = string_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.MessageContent.string_message)
}
inline ::XuChat::StringMessageInfo* MessageContent::_internal_mutable_string_message() {
  if (!_internal_has_string_message()) {
    clear_msg_content();
    set_has_string_message();
    msg_content_.string_message_ = CreateMaybeMessage< ::XuChat::StringMessageInfo >(GetArenaForAllocation());
  }
  return msg_content_.string_message_;
}
inline ::XuChat::StringMessageInfo* MessageContent::mutable_string_message() {
  ::XuChat::StringMessageInfo* _msg = _internal_mutable_string_message();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageContent.string_message)
  return _msg;
}

// .XuChat.FileMessageInfo file_message = 3;
inline bool MessageContent::_internal_has_file_message() const {
  return msg_content_case() == kFileMessage;
}
inline bool MessageContent::has_file_message() const {
  return _internal_has_file_message();
}
inline void MessageContent::set_has_file_message() {
  _oneof_case_[0] = kFileMessage;
}
inline void MessageContent::clear_file_message() {
  if (_internal_has_file_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_content_.file_message_;
    }
    clear_has_msg_content();
  }
}
inline ::XuChat::FileMessageInfo* MessageContent::release_file_message() {
  // @@protoc_insertion_point(field_release:XuChat.MessageContent.file_message)
  if (_internal_has_file_message()) {
    clear_has_msg_content();
    ::XuChat::FileMessageInfo* temp = msg_content_.file_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.file_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::XuChat::FileMessageInfo& MessageContent::_internal_file_message() const {
  return _internal_has_file_message()
      ? *msg_content_.file_message_
      : reinterpret_cast< ::XuChat::FileMessageInfo&>(::XuChat::_FileMessageInfo_default_instance_);
}
inline const ::XuChat::FileMessageInfo& MessageContent::file_message() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageContent.file_message)
  return _internal_file_message();
}
inline ::XuChat::FileMessageInfo* MessageContent::unsafe_arena_release_file_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:XuChat.MessageContent.file_message)
  if (_internal_has_file_message()) {
    clear_has_msg_content();
    ::XuChat::FileMessageInfo* temp = msg_content_.file_message_;
    msg_content_.file_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_file_message(::XuChat::FileMessageInfo* file_message) {
  clear_msg_content();
  if (file_message) {
    set_has_file_message();
    msg_content_.file_message_ = file_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.MessageContent.file_message)
}
inline ::XuChat::FileMessageInfo* MessageContent::_internal_mutable_file_message() {
  if (!_internal_has_file_message()) {
    clear_msg_content();
    set_has_file_message();
    msg_content_.file_message_ = CreateMaybeMessage< ::XuChat::FileMessageInfo >(GetArenaForAllocation());
  }
  return msg_content_.file_message_;
}
inline ::XuChat::FileMessageInfo* MessageContent::mutable_file_message() {
  ::XuChat::FileMessageInfo* _msg = _internal_mutable_file_message();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageContent.file_message)
  return _msg;
}

// .XuChat.SpeechMessageInfo speech_message = 4;
inline bool MessageContent::_internal_has_speech_message() const {
  return msg_content_case() == kSpeechMessage;
}
inline bool MessageContent::has_speech_message() const {
  return _internal_has_speech_message();
}
inline void MessageContent::set_has_speech_message() {
  _oneof_case_[0] = kSpeechMessage;
}
inline void MessageContent::clear_speech_message() {
  if (_internal_has_speech_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_content_.speech_message_;
    }
    clear_has_msg_content();
  }
}
inline ::XuChat::SpeechMessageInfo* MessageContent::release_speech_message() {
  // @@protoc_insertion_point(field_release:XuChat.MessageContent.speech_message)
  if (_internal_has_speech_message()) {
    clear_has_msg_content();
    ::XuChat::SpeechMessageInfo* temp = msg_content_.speech_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.speech_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::XuChat::SpeechMessageInfo& MessageContent::_internal_speech_message() const {
  return _internal_has_speech_message()
      ? *msg_content_.speech_message_
      : reinterpret_cast< ::XuChat::SpeechMessageInfo&>(::XuChat::_SpeechMessageInfo_default_instance_);
}
inline const ::XuChat::SpeechMessageInfo& MessageContent::speech_message() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageContent.speech_message)
  return _internal_speech_message();
}
inline ::XuChat::SpeechMessageInfo* MessageContent::unsafe_arena_release_speech_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:XuChat.MessageContent.speech_message)
  if (_internal_has_speech_message()) {
    clear_has_msg_content();
    ::XuChat::SpeechMessageInfo* temp = msg_content_.speech_message_;
    msg_content_.speech_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_speech_message(::XuChat::SpeechMessageInfo* speech_message) {
  clear_msg_content();
  if (speech_message) {
    set_has_speech_message();
    msg_content_.speech_message_ = speech_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.MessageContent.speech_message)
}
inline ::XuChat::SpeechMessageInfo* MessageContent::_internal_mutable_speech_message() {
  if (!_internal_has_speech_message()) {
    clear_msg_content();
    set_has_speech_message();
    msg_content_.speech_message_ = CreateMaybeMessage< ::XuChat::SpeechMessageInfo >(GetArenaForAllocation());
  }
  return msg_content_.speech_message_;
}
inline ::XuChat::SpeechMessageInfo* MessageContent::mutable_speech_message() {
  ::XuChat::SpeechMessageInfo* _msg = _internal_mutable_speech_message();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageContent.speech_message)
  return _msg;
}

// .XuChat.ImageMessageInfo image_message = 5;
inline bool MessageContent::_internal_has_image_message() const {
  return msg_content_case() == kImageMessage;
}
inline bool MessageContent::has_image_message() const {
  return _internal_has_image_message();
}
inline void MessageContent::set_has_image_message() {
  _oneof_case_[0] = kImageMessage;
}
inline void MessageContent::clear_image_message() {
  if (_internal_has_image_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_content_.image_message_;
    }
    clear_has_msg_content();
  }
}
inline ::XuChat::ImageMessageInfo* MessageContent::release_image_message() {
  // @@protoc_insertion_point(field_release:XuChat.MessageContent.image_message)
  if (_internal_has_image_message()) {
    clear_has_msg_content();
    ::XuChat::ImageMessageInfo* temp = msg_content_.image_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.image_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::XuChat::ImageMessageInfo& MessageContent::_internal_image_message() const {
  return _internal_has_image_message()
      ? *msg_content_.image_message_
      : reinterpret_cast< ::XuChat::ImageMessageInfo&>(::XuChat::_ImageMessageInfo_default_instance_);
}
inline const ::XuChat::ImageMessageInfo& MessageContent::image_message() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageContent.image_message)
  return _internal_image_message();
}
inline ::XuChat::ImageMessageInfo* MessageContent::unsafe_arena_release_image_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:XuChat.MessageContent.image_message)
  if (_internal_has_image_message()) {
    clear_has_msg_content();
    ::XuChat::ImageMessageInfo* temp = msg_content_.image_message_;
    msg_content_.image_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_image_message(::XuChat::ImageMessageInfo* image_message) {
  clear_msg_content();
  if (image_message) {
    set_has_image_message();
    msg_content_.image_message_ = image_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.MessageContent.image_message)
}
inline ::XuChat::ImageMessageInfo* MessageContent::_internal_mutable_image_message() {
  if (!_internal_has_image_message()) {
    clear_msg_content();
    set_has_image_message();
    msg_content_.image_message_ = CreateMaybeMessage< ::XuChat::ImageMessageInfo >(GetArenaForAllocation());
  }
  return msg_content_.image_message_;
}
inline ::XuChat::ImageMessageInfo* MessageContent::mutable_image_message() {
  ::XuChat::ImageMessageInfo* _msg = _internal_mutable_image_message();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageContent.image_message)
  return _msg;
}

inline bool MessageContent::has_msg_content() const {
  return msg_content_case() != MSG_CONTENT_NOT_SET;
}
inline void MessageContent::clear_has_msg_content() {
  _oneof_case_[0] = MSG_CONTENT_NOT_SET;
}
inline MessageContent::MsgContentCase MessageContent::msg_content_case() const {
  return MessageContent::MsgContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MessageInfo

// string message_id = 1;
inline void MessageInfo::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& MessageInfo::message_id() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageInfo.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageInfo::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.MessageInfo.message_id)
}
inline std::string* MessageInfo::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageInfo.message_id)
  return _s;
}
inline const std::string& MessageInfo::_internal_message_id() const {
  return message_id_.Get();
}
inline void MessageInfo::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageInfo::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageInfo::release_message_id() {
  // @@protoc_insertion_point(field_release:XuChat.MessageInfo.message_id)
  return message_id_.Release();
}
inline void MessageInfo::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.MessageInfo.message_id)
}

// string chat_session_id = 2;
inline void MessageInfo::clear_chat_session_id() {
  chat_session_id_.ClearToEmpty();
}
inline const std::string& MessageInfo::chat_session_id() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageInfo.chat_session_id)
  return _internal_chat_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageInfo::set_chat_session_id(ArgT0&& arg0, ArgT... args) {
 
 chat_session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.MessageInfo.chat_session_id)
}
inline std::string* MessageInfo::mutable_chat_session_id() {
  std::string* _s = _internal_mutable_chat_session_id();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageInfo.chat_session_id)
  return _s;
}
inline const std::string& MessageInfo::_internal_chat_session_id() const {
  return chat_session_id_.Get();
}
inline void MessageInfo::_internal_set_chat_session_id(const std::string& value) {
  
  chat_session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageInfo::_internal_mutable_chat_session_id() {
  
  return chat_session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageInfo::release_chat_session_id() {
  // @@protoc_insertion_point(field_release:XuChat.MessageInfo.chat_session_id)
  return chat_session_id_.Release();
}
inline void MessageInfo::set_allocated_chat_session_id(std::string* chat_session_id) {
  if (chat_session_id != nullptr) {
    
  } else {
    
  }
  chat_session_id_.SetAllocated(chat_session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_session_id_.IsDefault()) {
    chat_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.MessageInfo.chat_session_id)
}

// int64 timestamp = 3;
inline void MessageInfo::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t MessageInfo::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t MessageInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageInfo.timestamp)
  return _internal_timestamp();
}
inline void MessageInfo::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void MessageInfo::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:XuChat.MessageInfo.timestamp)
}

// .XuChat.UserInfo sender = 4;
inline bool MessageInfo::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool MessageInfo::has_sender() const {
  return _internal_has_sender();
}
inline void MessageInfo::clear_sender() {
  if (GetArenaForAllocation() == nullptr && sender_ != nullptr) {
    delete sender_;
  }
  sender_ = nullptr;
}
inline const ::XuChat::UserInfo& MessageInfo::_internal_sender() const {
  const ::XuChat::UserInfo* p = sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::XuChat::UserInfo&>(
      ::XuChat::_UserInfo_default_instance_);
}
inline const ::XuChat::UserInfo& MessageInfo::sender() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageInfo.sender)
  return _internal_sender();
}
inline void MessageInfo::unsafe_arena_set_allocated_sender(
    ::XuChat::UserInfo* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.MessageInfo.sender)
}
inline ::XuChat::UserInfo* MessageInfo::release_sender() {
  
  ::XuChat::UserInfo* temp = sender_;
  sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XuChat::UserInfo* MessageInfo::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:XuChat.MessageInfo.sender)
  
  ::XuChat::UserInfo* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::XuChat::UserInfo* MessageInfo::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::XuChat::UserInfo>(GetArenaForAllocation());
    sender_ = p;
  }
  return sender_;
}
inline ::XuChat::UserInfo* MessageInfo::mutable_sender() {
  ::XuChat::UserInfo* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageInfo.sender)
  return _msg;
}
inline void MessageInfo::set_allocated_sender(::XuChat::UserInfo* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:XuChat.MessageInfo.sender)
}

// .XuChat.MessageContent message = 5;
inline bool MessageInfo::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool MessageInfo::has_message() const {
  return _internal_has_message();
}
inline void MessageInfo::clear_message() {
  if (GetArenaForAllocation() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::XuChat::MessageContent& MessageInfo::_internal_message() const {
  const ::XuChat::MessageContent* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::XuChat::MessageContent&>(
      ::XuChat::_MessageContent_default_instance_);
}
inline const ::XuChat::MessageContent& MessageInfo::message() const {
  // @@protoc_insertion_point(field_get:XuChat.MessageInfo.message)
  return _internal_message();
}
inline void MessageInfo::unsafe_arena_set_allocated_message(
    ::XuChat::MessageContent* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XuChat.MessageInfo.message)
}
inline ::XuChat::MessageContent* MessageInfo::release_message() {
  
  ::XuChat::MessageContent* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XuChat::MessageContent* MessageInfo::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:XuChat.MessageInfo.message)
  
  ::XuChat::MessageContent* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::XuChat::MessageContent* MessageInfo::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::XuChat::MessageContent>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::XuChat::MessageContent* MessageInfo::mutable_message() {
  ::XuChat::MessageContent* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:XuChat.MessageInfo.message)
  return _msg;
}
inline void MessageInfo::set_allocated_message(::XuChat::MessageContent* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:XuChat.MessageInfo.message)
}

// -------------------------------------------------------------------

// FileDownloadData

// string file_id = 1;
inline void FileDownloadData::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& FileDownloadData::file_id() const {
  // @@protoc_insertion_point(field_get:XuChat.FileDownloadData.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileDownloadData::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileDownloadData.file_id)
}
inline std::string* FileDownloadData::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:XuChat.FileDownloadData.file_id)
  return _s;
}
inline const std::string& FileDownloadData::_internal_file_id() const {
  return file_id_.Get();
}
inline void FileDownloadData::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FileDownloadData::_internal_mutable_file_id() {
  
  return file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FileDownloadData::release_file_id() {
  // @@protoc_insertion_point(field_release:XuChat.FileDownloadData.file_id)
  return file_id_.Release();
}
inline void FileDownloadData::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileDownloadData.file_id)
}

// bytes file_content = 2;
inline void FileDownloadData::clear_file_content() {
  file_content_.ClearToEmpty();
}
inline const std::string& FileDownloadData::file_content() const {
  // @@protoc_insertion_point(field_get:XuChat.FileDownloadData.file_content)
  return _internal_file_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileDownloadData::set_file_content(ArgT0&& arg0, ArgT... args) {
 
 file_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileDownloadData.file_content)
}
inline std::string* FileDownloadData::mutable_file_content() {
  std::string* _s = _internal_mutable_file_content();
  // @@protoc_insertion_point(field_mutable:XuChat.FileDownloadData.file_content)
  return _s;
}
inline const std::string& FileDownloadData::_internal_file_content() const {
  return file_content_.Get();
}
inline void FileDownloadData::_internal_set_file_content(const std::string& value) {
  
  file_content_.Set(value, GetArenaForAllocation());
}
inline std::string* FileDownloadData::_internal_mutable_file_content() {
  
  return file_content_.Mutable(GetArenaForAllocation());
}
inline std::string* FileDownloadData::release_file_content() {
  // @@protoc_insertion_point(field_release:XuChat.FileDownloadData.file_content)
  return file_content_.Release();
}
inline void FileDownloadData::set_allocated_file_content(std::string* file_content) {
  if (file_content != nullptr) {
    
  } else {
    
  }
  file_content_.SetAllocated(file_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_content_.IsDefault()) {
    file_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileDownloadData.file_content)
}

// -------------------------------------------------------------------

// FileUploadData

// string file_name = 1;
inline void FileUploadData::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& FileUploadData::file_name() const {
  // @@protoc_insertion_point(field_get:XuChat.FileUploadData.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileUploadData::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileUploadData.file_name)
}
inline std::string* FileUploadData::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:XuChat.FileUploadData.file_name)
  return _s;
}
inline const std::string& FileUploadData::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileUploadData::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileUploadData::_internal_mutable_file_name() {
  
  return file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileUploadData::release_file_name() {
  // @@protoc_insertion_point(field_release:XuChat.FileUploadData.file_name)
  return file_name_.Release();
}
inline void FileUploadData::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault()) {
    file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileUploadData.file_name)
}

// int64 file_size = 2;
inline void FileUploadData::clear_file_size() {
  file_size_ = int64_t{0};
}
inline int64_t FileUploadData::_internal_file_size() const {
  return file_size_;
}
inline int64_t FileUploadData::file_size() const {
  // @@protoc_insertion_point(field_get:XuChat.FileUploadData.file_size)
  return _internal_file_size();
}
inline void FileUploadData::_internal_set_file_size(int64_t value) {
  
  file_size_ = value;
}
inline void FileUploadData::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:XuChat.FileUploadData.file_size)
}

// bytes file_content = 3;
inline void FileUploadData::clear_file_content() {
  file_content_.ClearToEmpty();
}
inline const std::string& FileUploadData::file_content() const {
  // @@protoc_insertion_point(field_get:XuChat.FileUploadData.file_content)
  return _internal_file_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileUploadData::set_file_content(ArgT0&& arg0, ArgT... args) {
 
 file_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XuChat.FileUploadData.file_content)
}
inline std::string* FileUploadData::mutable_file_content() {
  std::string* _s = _internal_mutable_file_content();
  // @@protoc_insertion_point(field_mutable:XuChat.FileUploadData.file_content)
  return _s;
}
inline const std::string& FileUploadData::_internal_file_content() const {
  return file_content_.Get();
}
inline void FileUploadData::_internal_set_file_content(const std::string& value) {
  
  file_content_.Set(value, GetArenaForAllocation());
}
inline std::string* FileUploadData::_internal_mutable_file_content() {
  
  return file_content_.Mutable(GetArenaForAllocation());
}
inline std::string* FileUploadData::release_file_content() {
  // @@protoc_insertion_point(field_release:XuChat.FileUploadData.file_content)
  return file_content_.Release();
}
inline void FileUploadData::set_allocated_file_content(std::string* file_content) {
  if (file_content != nullptr) {
    
  } else {
    
  }
  file_content_.SetAllocated(file_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_content_.IsDefault()) {
    file_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XuChat.FileUploadData.file_content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XuChat

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::XuChat::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XuChat::MessageType>() {
  return ::XuChat::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_base_2eproto
